<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Specification | VSAVM</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@400;600&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/site.css">
  </head>
  <body>
    <div class="site">
      <header class="header">
        <div class="brand">VSAVM</div>
        <nav class="nav">
          <a href="index.html">Home</a>
          <a href="specs/">Specs</a>
          <a href="theory/index.html">Theory</a>
          <a href="wiki/index.html">Wiki</a>
        </nav>
      </header>
      <main class="main content">
        <div class="section md-viewer">
          <h2>On this page</h2>
          <div id="md-toc" class="md-toc"></div>
        </div>
        <div class="section md-viewer">
          <p class="md-viewer-meta"><strong>Source:</strong> <a id="md-source-link" href="#"></a></p>
          <div id="md-render" class="md-render" aria-live="polite"></div>
        </div>
      </main>
      <footer class="footer">
        VSAVM is an Axiologic Research experiment within the Achilles project. This static documentation is written in clear academic English for engineers.
      </footer>
    </div>
    <script>
      function escapeHtml(text) {
        return text
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&#039;");
      }

      function isAbsoluteUrl(url) {
        return /^https?:\/\//i.test(url);
      }

      function slugify(text) {
        return text
          .toLowerCase()
          .replaceAll(/[^a-z0-9\s-]/g, "")
          .trim()
          .replaceAll(/\s+/g, "-")
          .replaceAll(/-+/g, "-");
      }

      function normalizeDocPath(doc) {
        if (!doc) return "specs/URS.md";
        return doc;
      }

      function baseDirForDoc(doc) {
        const idx = doc.lastIndexOf("/");
        return idx >= 0 ? doc.slice(0, idx + 1) : "";
      }

      function getBaseUrl() {
        const loc = window.location;
        if (loc.protocol === "file:") {
          const path = loc.pathname;
          const idx = path.lastIndexOf("/");
          return idx >= 0 ? "file://" + path.slice(0, idx + 1) : "";
        }
        return loc.origin + loc.pathname.replace(/\/[^\/]*$/, "/");
      }

      function resolveRelativeUrl(baseDir, url) {
        if (url.startsWith("#") || url.startsWith("/") || isAbsoluteUrl(url)) return url;
        if (url.includes("..")) return url;
        return `${baseDir}${url}`;
      }

      function viewerUrlFor(resolvedUrl) {
        const parts = resolvedUrl.split("#");
        const path = parts[0];
        const fragment = parts[1] ? `#${parts[1]}` : "";
        if (path.endsWith(".md") && path.startsWith("specs/")) {
          return `specs-viewer.html?doc=${encodeURIComponent(path)}${fragment}`;
        }
        return resolvedUrl;
      }

      function inlineMarkdown(text, baseDir) {
        const placeholders = [];
        let safe = escapeHtml(text);

        safe = safe.replaceAll(/`([^`]+)`/g, (_, code) => {
          const token = `\u0000CODE${placeholders.length}\u0000`;
          placeholders.push(`<code>${escapeHtml(code)}</code>`);
          return token;
        });

        safe = safe.replaceAll(/!\[([^\]]*)\]\(([^\)]+)\)/g, (_, alt, url) => {
          const resolved = resolveRelativeUrl(baseDir, url.trim());
          const src = escapeHtml(resolved);
          const a = escapeHtml(alt.trim());
          return `<img src="${src}" alt="${a}">`;
        });

        safe = safe.replaceAll(/\[([^\]]+)\]\(([^\)]+)\)/g, (_, label, url) => {
          const resolved = resolveRelativeUrl(baseDir, url.trim());
          const rewritten = viewerUrlFor(resolved);
          const safeLabel = escapeHtml(label);
          const safeUrl = escapeHtml(rewritten);
          return `<a href="${safeUrl}">${safeLabel}</a>`;
        });

        safe = safe.replaceAll(/~~([^~]+)~~/g, "<del>$1</del>");
        safe = safe.replaceAll(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        safe = safe.replaceAll(/__([^_]+)__/g, "<strong>$1</strong>");
        safe = safe.replaceAll(/\*([^*]+)\*/g, "<em>$1</em>");
        safe = safe.replaceAll(/(^|\s)_([^_]+)_(?=\s|$)/g, "$1<em>$2</em>");

        safe = safe.replaceAll(/\u0000CODE(\d+)\u0000/g, (_, idx) => placeholders[Number(idx)] || "");
        return safe;
      }

      function renderTable(lines) {
        const rows = lines
          .map((line) => line.trim())
          .filter((line) => line.startsWith("|") && line.endsWith("|"))
          .map((line) => line.slice(1, -1).split("|").map((cell) => cell.trim()));

        if (rows.length < 2) return null;
        const separator = rows[1].every((cell) => /^-+$/.test(cell.replaceAll(":", "").trim()));
        if (!separator) return null;

        const header = rows[0];
        const bodyRows = rows.slice(2);

        const thead = `<thead><tr>${header.map((c) => `<th>${inlineMarkdown(c, window.__mdBaseDir)}</th>`).join("")}</tr></thead>`;
        const tbody = `<tbody>${bodyRows
          .map((r) => `<tr>${r.map((c) => `<td>${inlineMarkdown(c, window.__mdBaseDir)}</td>`).join("")}</tr>`)
          .join("")}</tbody>`;

        return `<table>${thead}${tbody}</table>`;
      }

      function markdownToHtml(markdown, baseDir) {
        const lines = markdown.replaceAll("\r\n", "\n").split("\n");
        const out = [];
        const toc = [];
        let paragraph = [];
        let code = null;
        let tableBuffer = [];
        let quoteBuffer = [];
        let listBuffer = [];
        let orderedListBuffer = [];

        function flushList() {
          if (listBuffer.length === 0) return;
          const items = listBuffer.map((t) => `<li>${inlineMarkdown(t, baseDir)}</li>`).join("");
          out.push(`<ul>${items}</ul>`);
          listBuffer = [];
        }

        function flushOrderedList() {
          if (orderedListBuffer.length === 0) return;
          const items = orderedListBuffer.map((t) => `<li>${inlineMarkdown(t, baseDir)}</li>`).join("");
          out.push(`<ol>${items}</ol>`);
          orderedListBuffer = [];
        }

        function flushQuote() {
          if (quoteBuffer.length === 0) return;
          const text = quoteBuffer.join(" ").trim();
          out.push(`<blockquote><p>${inlineMarkdown(text, baseDir)}</p></blockquote>`);
          quoteBuffer = [];
        }

        function flushParagraph() {
          if (paragraph.length === 0) return;
          const text = paragraph.join(" ").trim();
          if (text.length > 0) out.push(`<p>${inlineMarkdown(text, baseDir)}</p>`);
          paragraph = [];
        }

        function flushTable() {
          if (tableBuffer.length === 0) return false;
          const tableHtml = renderTable(tableBuffer);
          if (tableHtml) {
            out.push(tableHtml);
            tableBuffer = [];
            return true;
          }
          return false;
        }

        for (let i = 0; i < lines.length; i++) {
          const raw = lines[i];

          if (raw.startsWith("```")) {
            flushList();
            flushOrderedList();
            flushQuote();
            flushParagraph();
            flushTable();
            if (code === null) {
              code = [];
            } else {
              out.push(`<pre><code>${escapeHtml(code.join("\n"))}</code></pre>`);
              code = null;
            }
            continue;
          }

          if (code !== null) {
            code.push(raw);
            continue;
          }

          const line = raw.trim();

          if (line.length === 0) {
            flushList();
            flushOrderedList();
            flushQuote();
            flushParagraph();
            flushTable();
            continue;
          }

          if (/^(-{3,}|\*{3,}|_{3,})$/.test(line)) {
            flushList();
            flushOrderedList();
            flushQuote();
            flushParagraph();
            flushTable();
            out.push("<hr>");
            continue;
          }

          if (line.startsWith(">")) {
            flushList();
            flushOrderedList();
            flushParagraph();
            flushTable();
            quoteBuffer.push(line.replace(/^>\s?/, ""));
            continue;
          } else if (quoteBuffer.length > 0) {
            flushQuote();
          }

          if (line.startsWith("|") && line.endsWith("|")) {
            flushList();
            flushOrderedList();
            flushParagraph();
            tableBuffer.push(line);
            continue;
          }

          if (tableBuffer.length > 0) {
            if (!flushTable()) {
              paragraph.push(...tableBuffer);
              tableBuffer = [];
            }
          }

          const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
          if (headingMatch) {
            flushList();
            flushOrderedList();
            flushParagraph();
            const level = headingMatch[1].length;
            const text = headingMatch[2].trim();
            const id = slugify(text);
            if (level <= 3) toc.push({ level, id, text });
            out.push(`<h${level} id="${escapeHtml(id)}">${inlineMarkdown(text, baseDir)}</h${level}>`);
            continue;
          }

          const bulletMatch = line.match(/^[-*+]\s+(.*)$/);
          if (bulletMatch) {
            flushParagraph();
            flushTable();
            flushOrderedList();
            listBuffer.push(bulletMatch[1].trim());
            continue;
          } else if (listBuffer.length > 0) {
            flushList();
          }

          const orderedMatch = line.match(/^\d+\.\s+(.*)$/);
          if (orderedMatch) {
            flushParagraph();
            flushTable();
            flushList();
            orderedListBuffer.push(orderedMatch[1].trim());
            continue;
          } else if (orderedListBuffer.length > 0) {
            flushOrderedList();
          }

          const imageOnly = line.match(/^!\[([^\]]*)\]\(([^\)]+)\)\s*$/);
          if (imageOnly) {
            flushList();
            flushOrderedList();
            flushParagraph();
            flushTable();
            const alt = imageOnly[1].trim();
            const url = imageOnly[2].trim();
            const resolved = resolveRelativeUrl(baseDir, url);
            out.push(`<figure class="md-figure"><img src="${escapeHtml(resolved)}" alt="${escapeHtml(alt)}">${alt ? `<figcaption>${escapeHtml(alt)}</figcaption>` : ""}</figure>`);
            continue;
          }

          paragraph.push(line);
        }

        if (code !== null) out.push(`<pre><code>${escapeHtml(code.join("\n"))}</code></pre>`);
        flushList();
        flushOrderedList();
        flushQuote();
        flushParagraph();
        flushTable();
        return { html: out.join("\n"), toc };
      }

      function getDocParam() {
        const url = new URL(window.location.href);
        const doc = url.searchParams.get("doc") || "specs/URS.md";
        return doc;
      }

      function isAllowedDoc(path) {
        return path.startsWith("specs/") && path.endsWith(".md") && !path.includes("..");
      }

      function extractTitle(html) {
        const match = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
        if (match) return match[1].trim();
        const h2Match = html.match(/<h2[^>]*>([^<]+)<\/h2>/i);
        if (h2Match) return h2Match[1].trim();
        return null;
      }

      async function loadAndRender() {
        const doc = normalizeDocPath(getDocParam());
        const baseDir = baseDirForDoc(doc);
        window.__mdBaseDir = baseDir;
        const render = document.getElementById("md-render");
        const link = document.getElementById("md-source-link");
        const tocEl = document.getElementById("md-toc");

        const docName = doc.split("/").pop().replace(".md", "");
        link.textContent = docName;
        link.setAttribute("href", doc);

        if (!isAllowedDoc(doc)) {
          render.innerHTML = "<p>Invalid document path.</p>";
          return;
        }

        try {
          const response = await fetch(doc, { cache: "no-store" });
          if (!response.ok) {
            render.innerHTML = `<p>Failed to load <code>${escapeHtml(doc)}</code>. HTTP ${response.status}.</p>`;
            return;
          }
          const text = await response.text();
          const rendered = markdownToHtml(text, baseDir);
          render.innerHTML = rendered.html;

          const docTitle = extractTitle(rendered.html);
          if (docTitle) {
            document.title = `${docTitle} | VSAVM`;
          }

          if (rendered.toc.length === 0) {
            tocEl.innerHTML = "<p>No headings found.</p>";
          } else {
            const tocHtml = rendered.toc
              .map((h) => `<a class="md-toc-link md-toc-level-${h.level}" href="#${escapeHtml(slugify(h.text))}">${escapeHtml(h.text)}</a>`)
              .join("");
            tocEl.innerHTML = tocHtml;
          }

          if (window.location.hash) {
            const id = window.location.hash.slice(1);
            const target = document.getElementById(id);
            if (target) target.scrollIntoView({ block: "start" });
          }
        } catch (err) {
          render.innerHTML = `<p>Failed to load <code>${escapeHtml(doc)}</code>. If viewing locally, serve with a static server (e.g., <code>npx serve docs</code>).</p>`;
        }
      }

      loadAndRender();
    </script>
  </body>
</html>
