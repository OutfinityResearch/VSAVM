<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Structural scope isolation | VSAVM</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@400;600&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../assets/site.css">
  </head>
  <body>
    <div class="site">
      <header class="header">
        <div class="brand">VSAVM</div>
        <nav class="nav">
          <a href="../index.html">Home</a>
          <a href="../specs/">Specs</a>
          <a href="../theory/index.html">Theory</a>
          <a href="../wiki/index.html">Wiki</a>
          <a href="../eval/index.html">Eval</a>
        </nav>
      </header>
      <main class="main content">
        <h1>Structural scope isolation</h1>
<p>VSAVM prevents context bleeding by deriving scope only from structural separators in the data (DS010 / NFS11). Scope is a structural path, not a hand-assigned topic label.</p>

<h2>Problem: polysemy and source mixing</h2>
<p>Real corpora contain repeated strings that refer to different things in different places, and they often contain mutually incompatible statements. If the system treats all assertions as globally active, contradiction checks either explode or become meaningless.</p>
<ul>
  <li><strong>Polysemy</strong>: the same surface form appears in multiple sources with different referents.</li>
  <li><strong>Quoted passages</strong>: a quote can contradict the narrator without being an error.</li>
  <li><strong>Alternative versions</strong>: two documents can disagree without either being “wrong” inside its own context.</li>
</ul>

<h2>Design rule (enforced in code)</h2>
<p><strong>Scopes must emerge from structure.</strong> A scope is derived from separators such as document boundaries, headings, paragraphs, speakers, scenes, functions, and other structural cuts present in the input stream.</p>
<p>The implementation rejects any attempt to create a scope that starts with <code>['domain', ...]</code>. This is enforced by <code>createScopeId</code> in <code>src/core/types/identifiers.mjs</code>.</p>

<h2>What a scope looks like</h2>
<p>Scope IDs are hierarchical paths. The exact tokens depend on the modality ingest layer, but they must always correspond to structural separators (never to a domain name).</p>
<pre><code>['document', 'doc_0042', 'section_3', 'paragraph_12']
['file', 'src/parser.mjs', 'function_parse', 'block_2']
['conversation', 'turn_17', 'assistant', 'sentence_2']
['dataset', 'record_128']</code></pre>
<p>Containment is prefix-based. For example, <code>['dataset','record_128']</code> contains all deeper scopes such as <code>['dataset','record_128','byte_17']</code>.</p>

<h2>How scope is derived at runtime (current implementation)</h2>
<ol>
  <li><strong>Ingest events</strong> with optional <code>contextPath</code> arrays (preferred) using DS007 event structures.</li>
  <li><strong>Detect separators</strong> with the DS010 VSA detector (<code>detectStructuralSeparators</code>) when explicit context is missing, or to add a gradient-based boundary signal.</li>
  <li><strong>Create a ScopeId</strong> at a position using <code>createStructuralScopeId(events, position, separators)</code>:
    <ul>
      <li>If the event has a <code>contextPath</code>, use it directly.</li>
      <li>Otherwise, build a fallback path from the strongest detected separators (e.g., <code>['stream','section_boundary_120','minor_boundary_318']</code>).</li>
    </ul>
  </li>
  <li><strong>Attach scope to facts</strong> so closure and contradiction checks are localized.</li>
  <li><strong>Query within a scope</strong> by selecting a structural region (via scope containment) instead of merging unrelated regions.</li>
</ol>

<h2>Context selection is structural, not topical</h2>
<p>When the user wants “the other meaning”, the system switches by structural reference (document/section/file/record), not by picking a domain.</p>
<pre><code>User: "In record_12, what does 'Python' refer to?"
System: [answers within scope ['dataset','record_12']]

User: "Now answer using record_99 instead."
System: [answers within scope ['dataset','record_99']]</code></pre>

<h2>Why this matters for correctness</h2>
<ul>
  <li><strong>Contradictions become computable</strong>: a conflict is opposing polarity for the same canonical FactId within the same scope.</li>
  <li><strong>Separator errors are localized</strong>: segmentation mistakes do not contaminate the entire corpus.</li>
  <li><strong>Modality agnostic</strong>: the boundary tokens differ across modalities, but the rule (“structure only”) stays the same.</li>
</ul>

<p>Related: <a href="structure-and-scope.html">Structural boundaries and scope</a>, <a href="../specs-viewer.html?doc=specs/DS010-emergent-separator-discovery.md">DS010</a>, <a href="../specs/">Specs</a></p>
      </main>
      <footer class="footer">
        VSAVM is an Axiologic Research experiment within the Achilles project. This static documentation is written in clear academic English for engineers.
      </footer>
    </div>
  </body>
</html>
