<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Question compilation pipeline | VSAVM</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@400;600&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../assets/site.css">
  </head>
  <body>
    <div class="site">
      <header class="header">
        <div class="brand">VSAVM</div>
        <nav class="nav">
          <a href="../index.html">Home</a>
          <a href="../specs/">Specs</a>
          <a href="../theory/index.html">Theory</a>
          <a href="../wiki/index.html">Wiki</a>
        </nav>
      </header>
      <main class="main content">
        <h1>Question compilation pipeline</h1>
<p>This page is a theory note. It expands the topic in short chapters and defines terminology without duplicating the formal specification documents.</p><p>The diagram has a transparent background and is intended to be read together with the caption and the sections below.</p>
<p>Related wiki pages: <a href="../wiki/vm.html">VM</a>, <a href="../wiki/event-stream.html">event stream</a>, <a href="../wiki/vsa.html">VSA</a>, <a href="../wiki/bounded-closure.html">bounded closure</a>, <a href="../wiki/consistency-contract.html">consistency contract</a>, <a href="../wiki/query-compiler.html">query compiler</a>, <a href="../wiki/schema.html">schema</a>.</p>
<p>Related specs: <a href="../specs-viewer.html?doc=specs/DS003-query-compilation-search.md">DS003</a>.</p>

<h2>Overview</h2>
<p>A question is treated as a request to produce an executable query program. The pipeline is explicit to support audit and control: normalization creates a structured span, retrieval proposes candidate schemas, slot filling binds discrete values, and compilation emits a program in the VM instruction set. This transformation operates through a learned pipeline rather than hand-coded rules.</p>

<h2>Natural language to query compilation</h2>
<p>The compilation process follows explicit stages:</p>
<ul>
  <li><strong>Query normalization</strong>: Convert input text to the standard event stream representation. Identify interrogative markers, entity references, relationship indicators, and logical connectives.</li>
  <li><strong>Entity identification</strong>: Disambiguate entity mentions (specific individuals, general categories, abstract concepts) using local query context and global knowledge base context. Maintain coreference tracking for pronouns and definite descriptions.</li>
  <li><strong>Schema retrieval</strong>: Use VSA similarity measures to identify candidate schemas from the library. Hypervector comparison produces a ranked list of potential matches that handle linguistic variations.</li>
  <li><strong>Schema matching</strong>: Evaluate structural compatibility beyond surface similarity. Maintain multiple candidate schemas rather than committing to a single interpretation early.</li>
</ul>

<h2>Slot filling and program instantiation</h2>
<p>Slot filling binds entities, roles, and references using discrete matching and coreference heuristics, augmented by associative retrieval:</p>
<ul>
  <li><strong>Direct matching</strong>: Query elements corresponding exactly to schema slots.</li>
  <li><strong>Type-based inference</strong>: Use slot type constraints to identify appropriate elements even with different surface forms.</li>
  <li><strong>Semantic association</strong>: VSA similarity measures identify related elements when direct matching fails.</li>
</ul>
<p>Complex queries may require multiple schemas combined or nested. The composition system maintains explicit data flow graphs tracking information movement through composite reasoning.</p>
<p>Program instantiation translates filled schemas into executable VM instruction sequences, including optimization steps: common subexpression identification, redundant operation elimination, and operation reordering for cache locality.</p>

<h2>Program search and selection</h2>
<p>The search process explores the space of possible reasoning strategies:</p>
<ul>
  <li><strong>Candidate generation</strong>: Modify existing programs by changing parameters, reordering operations, or substituting alternative sub-programs. Learned heuristics guide exploration toward promising directions.</li>
  <li><strong>Population management</strong>: Maintain candidate diversity through mutation and recombination. Use fitness-based selection while preserving potentially valuable less-fit candidates.</li>
  <li><strong>MDL-based scoring</strong>: Minimum Description Length balances performance and simplicity. Score components include complexity (program length/intricacy), accuracy (correct results on test cases), and generality (performance on unseen examples). Computational efficiency is also weighted.</li>
  <li><strong>Consistency checking</strong>: Each candidate is evaluated via bounded closure analysis to prevent logical contradictions.</li>
  <li><strong>Beam pruning</strong>: Retain only the most promising candidates at each stage while maintaining diversity to avoid premature convergence.</li>
</ul>

<h2>Schema learning and consolidation</h2>
<p>The schema learning process discovers recurring patterns in query-program relationships:</p>
<ul>
  <li><strong>Pattern recognition</strong>: Statistical analysis of compilation logs identifies correlations between linguistic patterns and reasoning strategies. Rigorous significance testing ensures genuine regularities.</li>
  <li><strong>Compression-driven emergence</strong>: Schemas providing significant MDL compression are promoted. The analysis evaluates both individual schema benefits and interaction effects with other schemas.</li>
  <li><strong>Schema abstraction</strong>: Hierarchical clustering of similar query-program pairs creates general patterns. Common structure is preserved while varying aspects are parameterized.</li>
  <li><strong>Consolidation triggers</strong>: Conservative criteria require substantial evidence before creating or modifying schemas. Validation on held-out examples ensures generalization beyond training data.</li>
  <li><strong>Schema generalization</strong>: Existing schemas can be extended for new query types through careful analysis of differences from existing patterns.</li>
</ul>

<h2>Multimodal query processing</h2>
<p>Queries spanning multiple input modalities require sophisticated coordination:</p>
<ul>
  <li><strong>Cross-modal reference resolution</strong>: Determine when entities in different modalities refer to the same real-world objects. Combine explicit linking (demonstratives, temporal synchronization) with implicit similarity-based association. Maintain uncertainty estimates for correspondence hypotheses.</li>
  <li><strong>Temporal and spatial slot filling</strong>: Resolve absolute and relative temporal references against audio/video timestamps. Align spatial references with coordinate systems and object locations in visual inputs.</li>
  <li><strong>Unified execution</strong>: The VM operates seamlessly across different symbolic representations through the canonical fact format. Cross-modal consistency checking accounts for modality-specific error patterns and uncertainty characteristics.</li>
  <li><strong>Modality-specific adaptations</strong>: Learned associations between reasoning strategies and modality characteristics enable optimized strategy selection.</li>
</ul>

<h2>Managing ambiguity</h2>
<p>Instead of forcing a single interpretation, VSAVM carries multiple candidate programs in a beam. Candidates are evaluated by explanatory fit and by early closure checks that detect contradictions. This makes uncertainty explicit and supports conditional outputs when necessary.</p>

<h2>Engineering implications</h2>
<p>Because compilation is explicit, it is testable. You can measure how often a schema is retrieved, how often slot filling is ambiguous, and how often a candidate fails under closure. These metrics can guide consolidation and improve robustness over time.</p>
<figure class="diagram">
<svg viewBox="0 0 800 280" role="img" aria-label="Question compilation diagram">
  <defs>
    <linearGradient id="sky" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#e8f3ff"/>
      <stop offset="1" stop-color="#d6f5e8"/>
    </linearGradient>
    <linearGradient id="deep" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#0b6eff"/>
      <stop offset="1" stop-color="#16b879"/>
    </linearGradient>
  </defs>
  <rect x="50" y="40" rx="12" ry="12" width="140" height="50" fill="url(#sky)" stroke="#7fb3e6" stroke-width="2"/>
  <text x="120" y="70" text-anchor="middle" font-size="13" fill="#0b1a2b" font-family="Space Grotesk">Normalize</text>
  <line x1="190" y1="65" x2="230" y2="65" stroke="url(#deep)" stroke-width="3" stroke-linecap="round"/>
  <polygon points="220,60 220,70 230,65" fill="#16b879"/>
  <rect x="230" y="40" rx="12" ry="12" width="140" height="50" fill="url(#sky)" stroke="#7fb3e6" stroke-width="2"/>
  <text x="300" y="70" text-anchor="middle" font-size="13" fill="#0b1a2b" font-family="Space Grotesk">Retrieve</text>
  <line x1="370" y1="65" x2="410" y2="65" stroke="url(#deep)" stroke-width="3" stroke-linecap="round"/>
  <polygon points="400,60 400,70 410,65" fill="#16b879"/>
  <rect x="410" y="40" rx="12" ry="12" width="140" height="50" fill="url(#sky)" stroke="#7fb3e6" stroke-width="2"/>
  <text x="480" y="70" text-anchor="middle" font-size="13" fill="#0b1a2b" font-family="Space Grotesk">Fill slots</text>
  <line x1="550" y1="65" x2="590" y2="65" stroke="url(#deep)" stroke-width="3" stroke-linecap="round"/>
  <polygon points="580,60 580,70 590,65" fill="#16b879"/>
  <rect x="590" y="40" rx="12" ry="12" width="140" height="50" fill="url(#sky)" stroke="#7fb3e6" stroke-width="2"/>
  <text x="660" y="70" text-anchor="middle" font-size="13" fill="#0b1a2b" font-family="Space Grotesk">Instantiate</text>
  <rect x="150" y="120" rx="12" ry="12" width="480" height="50" fill="url(#sky)" stroke="#7fb3e6" stroke-width="2"/>
  <text x="390" y="150" text-anchor="middle" font-size="13" fill="#0b1a2b" font-family="Space Grotesk">Beam: search, MDL scoring, consistency checking</text>
  <line x1="480" y1="90" x2="390" y2="120" stroke="#0b6eff" stroke-width="3" stroke-linecap="round"/>
  <polygon points="395,115 400,125 390,120" fill="#0b6eff"/>
  <rect x="150" y="200" rx="12" ry="12" width="220" height="50" fill="url(#sky)" stroke="#7fb3e6" stroke-width="2"/>
  <text x="260" y="230" text-anchor="middle" font-size="13" fill="#0b1a2b" font-family="Space Grotesk">Schema learning</text>
  <rect x="410" y="200" rx="12" ry="12" width="220" height="50" fill="url(#sky)" stroke="#7fb3e6" stroke-width="2"/>
  <text x="520" y="230" text-anchor="middle" font-size="13" fill="#0b1a2b" font-family="Space Grotesk">Multimodal coord</text>
  <line x1="390" y1="170" x2="260" y2="200" stroke="#0b6eff" stroke-width="2" stroke-dasharray="5,5"/>
  <line x1="390" y1="170" x2="520" y2="200" stroke="#0b6eff" stroke-width="2" stroke-dasharray="5,5"/>
</svg>
<figcaption>Questions are compiled into executable programs through explicit stages, with ambiguity managed by beam evaluation and consistency checks. Schema learning and multimodal coordination extend the core pipeline.</figcaption>
</figure>
<h2>References</h2>
<p><a href="https://en.wikipedia.org/wiki/Program_synthesis">Program synthesis (Wikipedia)</a> <a href="https://en.wikipedia.org/wiki/Beam_search">Beam search (Wikipedia)</a> <a href="https://en.wikipedia.org/wiki/Information_retrieval">Information retrieval (Wikipedia)</a> <a href="https://en.wikipedia.org/wiki/Minimum_description_length">Minimum description length (Wikipedia)</a></p>
      </main>
      <footer class="footer">
        VSAVM is an Axiologic Research experiment within the Achilles project. This static documentation is written in clear academic English for engineers.
      </footer>
    </div>
  </body>
</html>
